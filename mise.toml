# mise.toml â€” AionUI Development Environment
# https://mise.jdx.dev
#
# This file defines the project's tool versions, environment variables, and tasks.
# Commit this file to version control. Use `mise.local.toml` for personal overrides.
#
# Quick start:
#   mise install        # Install all tools
#   mise run dev        # Start development server
#   mise run lint       # Run linting
#   mise run test       # Run tests

# Hard minimum: errors if unmet. Soft minimum: warns but continues.
# Hard ensures hooks/prepare/lockfile features work. Soft recommends latest for bug fixes.
min_version = { hard = "2025.1.0", soft = "2026.1.0" }

[tools]
# Node.js â€” pinned to 24 LTS (Electron 37 requires Node >= 22)
# We pin to the major version; mise.lock stores the exact resolved version.
# Contributors can override locally via mise.local.toml if needed.
node = "24"

# git-cliff â€” changelog generator (https://git-cliff.org)
# Major-pinned: auto-updates within 2.x, exact version locked in mise.lock.
git-cliff = "2"

# Drift Detect â€” code pattern analysis and health scoring
# Used for pattern validation, drift detection, and AI context export
"npm:driftdetect" = "latest"
"npm:driftdetect-mcp" = "latest"

# npm â€” Node 24 bundles npm 11.6.x, but the project standardizes on npm 11.9+
# (see engines in package.json). We upgrade npm inside Node's prefix via
# [hooks.postinstall] because mise's npm tool (npm:npm backend) installs to a
# separate directory that gets shadowed by Node's bundled npm in PATH.
# See: jdx/mise#7083

[env]
# Add node_modules/.bin to PATH so locally-installed CLIs work without npx
_.path = ["{{config_root}}/node_modules/.bin"]

# Default NODE_ENV for development (override in mise.local.toml or shell)
NODE_ENV = "{{ env.NODE_ENV | default(value='development') }}"

[settings]
# Enable experimental features for hooks, prepare, and lockfile support
experimental = true

# Lockfile â€” ensures reproducible tool versions across machines and CI.
# mise.lock is committed to version control (see dev-tools/mise-lock docs).
lockfile = true

# Disable tool status display â€” noisy when global config has many tools
# Use `mise ls` to see active tools for this project
status.show_tools = false

# Warn when dependencies are stale (e.g., package-lock.json newer than node_modules/).
# Works with [prepare.npm] below.
status.show_prepare_stale = true

[hooks]
# Only install project-specific tools â€” not inherited global tools
# This prevents slow startup and terminal issues with large global configs
enter = "mise install -q node git-cliff npm:driftdetect npm:driftdetect-mcp 2>/dev/null || true"

# Upgrade npm inside Node's prefix after tool install.
# Only runs when npm major version doesn't match expected.
postinstall = 'npm -v 2>/dev/null | grep -q "^11\\." || npm install -g npm@11 >/dev/null 2>&1 || true'

# â”€â”€â”€ Prepare â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Auto-detect stale dependencies and install them before task execution.
# See: https://mise.jdx.dev/dev-tools/prepare.html

[prepare.npm]
# When auto=true, `npm install` runs automatically before `mise run`/`mise x`
# if package-lock.json is newer than node_modules/. Skip with --no-prepare.
auto = true

# â”€â”€â”€ Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# These wrap npm scripts for a unified `mise run <task>` experience.
# Key benefit: `mise run` auto-installs the correct Node.js version first.

[tasks.install]
alias = "i"
description = "Install npm dependencies"
hide = true  # Internal utility â€” [prepare.npm] handles auto-install. Use `mise run install` if needed.
run = "npm install"

[tasks.dev]
alias = "d"
description = "Start Electron development server with hot reload"
# Dependencies auto-installed by [prepare.npm] when stale (no manual depends needed)
run = "npm start"

[tasks.webui]
description = "Start WebUI server (local access)"
run = "npm run webui"

[tasks."webui:remote"]
description = "Start WebUI server (remote access)"
run = "npm run webui:remote"

[tasks.lint]
alias = "l"
description = "Run ESLint"
# Source tracking: skips re-runs when no source files have changed.
# outputs defaults to { auto = true } â€” mise uses an internal marker file.
# Use `mise run lint --force` to bypass source checking.
sources = ["src/**/*.ts", "src/**/*.tsx", "src/**/*.js", ".eslintrc.json"]
run = "npm run lint"

[tasks."lint:fix"]
description = "Run ESLint with auto-fix"
run = "npm run lint:fix"

[tasks.format]
description = "Format code with Prettier"
run = "npm run format"

[tasks."format:check"]
description = "Check code formatting (no changes)"
sources = ["src/**/*.ts", "src/**/*.tsx", "src/**/*.js", "src/**/*.css", "src/**/*.json", ".prettierrc.json"]
run = "npm run format:check"

[tasks.test]
alias = "t"
description = "Run all tests"
sources = ["src/**/*.ts", "src/**/*.tsx", "src/**/*.test.*", "jest.config.js", "package.json"]
run = "npm test"

[tasks."test:watch"]
description = "Run tests in watch mode"
run = "npm run test:watch"

[tasks."test:coverage"]
description = "Run tests with coverage report"
run = "npm run test:coverage"

[tasks."test:contract"]
description = "Run contract tests"
run = "npm run test:contract"

[tasks."test:integration"]
description = "Run integration tests"
run = "npm run test:integration"

[tasks.build]
alias = "b"
description = "Build for current platform (macOS arm64 + x64)"
# Source tracking: skip rebuild when no source files have changed.
# Use `mise run build --force` to always rebuild.
sources = ["src/**/*.ts", "src/**/*.tsx", "src/**/*.css", "package.json", "forge.config.ts", "tsconfig.json", "webpack.*.ts"]
outputs = ["out/**/*"]
run = "npm run build"

[tasks."build:branded"]
description = "Build with custom brand name (set AIONUI_BRAND_NAME in env or mise.local.toml)"
usage = '''
flag "--brand <name>" help="Custom brand name (overrides AIONUI_BRAND_NAME env)"
'''
run = """
#!/usr/bin/env bash
set -e
if [ -n "${usage_brand:-}" ]; then
  export AIONUI_BRAND_NAME="${usage_brand}"
fi
echo "Building with brand: ${AIONUI_BRAND_NAME:-AionUi}"
npm run build
"""

[tasks."build:mac"]
description = "Build macOS distribution"
run = "npm run dist:mac"

[tasks."build:win"]
description = "Build Windows distribution"
run = "npm run dist:win"

[tasks."build:linux"]
description = "Build Linux distribution"
run = "npm run dist:linux"

[tasks.clean]
description = "Clean build artifacts (use --all to also remove node_modules)"
confirm = "This will delete build artifacts.{% if usage.all %} Including node_modules/ (~500MB).{% endif %} Continue?"
usage = '''
flag "--all" help="Also remove node_modules/ (requires fresh npm install)"
flag "--dry-run" help="Show what would be removed without deleting"
'''
run = """
#!/usr/bin/env bash
set -e

targets=("out/" "dist/" ".webpack/")
if [ "${usage_all:-false}" = "true" ]; then
  targets+=("node_modules/")
fi

if [ "${usage_dry_run:-false}" = "true" ]; then
  echo "Would remove:"
  for t in "${targets[@]}"; do
    [ -e "$t" ] && echo "  $t ($(du -sh "$t" 2>/dev/null | cut -f1))" || echo "  $t (not present)"
  done
  exit 0
fi

echo "Cleaning build artifacts..."
for t in "${targets[@]}"; do
  [ -e "$t" ] && rm -rf "$t" && echo "  âœ“ Removed $t" || echo "  â—‹ $t (not present)"
done
echo "âœ“ Clean complete"
"""

[tasks.ci]
description = "Run full CI checks (lint + format + test â€” runs in parallel, skips unchanged)"
# lint, format:check, and test have source tracking â€” they'll skip if no files changed.
# Use `mise run ci --force` to run all checks regardless.
depends = ["lint", "format:check", "test"]

[tasks.info]
description = "Print project and environment information"
run = """
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘          AionUI Dev Environment          â•‘"
echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
echo "â•‘ mise:     $(mise -v)"
echo "â•‘ Node.js:  $(node -v)"
echo "â•‘ npm:      $(npm -v)"
echo "â•‘ Electron: $(node -e \"console.log(require('./package.json').devDependencies.electron)\")"
echo "â•‘ NODE_ENV: $NODE_ENV"
echo "â•‘ Platform: $(uname -ms)"
echo "â• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£"
PREP=$(mise prepare --dry-run 2>&1 | head -1); echo "â•‘ Prepare:  ${PREP:-fresh}"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
"""

# â”€â”€â”€ Docker Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Build and run AionUI Docker images with versions from mise.lock.
# See: deploy/docker/Dockerfile, deploy/docker/docker-compose.yml

[tasks."docker:build"]
description = "Build Docker image with pinned tool versions from mise.lock"
usage = '''
flag "--arch <arch>" help="Target architecture" default="arm64" {
  choices "arm64" "amd64"
}
flag "--no-cache" help="Build without Docker layer cache"
flag "--tag <tag>" help="Image tag" default="aionui:latest"
flag "--brand <name>" help="Custom brand name (baked into build)"
'''
run = """
#!/usr/bin/env bash
set -e

# Extract pinned versions from mise.lock to pass as Docker build args.
# This ensures Docker uses the exact same Node/npm versions as local dev.
NODE_VERSION=$(grep -A1 'tools.node' mise.lock | grep version | head -1 | sed 's/.*= "//' | sed 's/"//')
# npm isn't in mise.lock (installed via postinstall hook); read from Dockerfile default
NPM_VERSION=$(grep 'ARG NPM_VERSION=' deploy/docker/Dockerfile | head -1 | sed 's/ARG NPM_VERSION=//')

# Use --brand flag, env var, or default
BRAND="${usage_brand:-${AIONUI_BRAND_NAME:-AionUi}}"

echo "Building Docker image with:"
echo "  Node.js:    ${NODE_VERSION}"
echo "  npm:        ${NPM_VERSION}"
echo "  Arch:       ${usage_arch?}"
echo "  Tag:        ${usage_tag?}"
echo "  Brand:      ${BRAND}"
echo "  CLI tools:  All included (Claude, Qwen, Codex, iFlow, Auggie, Copilot, Qoder, OpenCode)"
echo ""

CACHE_FLAG=""
if [ "${usage_no_cache:-false}" = "true" ]; then
  CACHE_FLAG="--no-cache"
fi

docker build \
  -f deploy/docker/Dockerfile \
  --build-arg NODE_VERSION="${NODE_VERSION}" \
  --build-arg NPM_VERSION="${NPM_VERSION}" \
  --build-arg TARGETARCH="${usage_arch?}" \
  --build-arg AIONUI_BRAND_NAME="${BRAND}" \
  ${CACHE_FLAG} \
  -t "${usage_tag?}" \
  .
"""

[tasks."docker:up"]
description = "Start AionUI Docker container (docker-compose)"
run = "docker compose -f deploy/docker/docker-compose.yml up -d"

[tasks."docker:up:https"]
description = "Start AionUI Docker container (docker-compose) with HTTPS"
run = "docker compose -f deploy/docker/docker-compose.yml --profile https up -d"

[tasks."docker:down"]
description = "Stop AionUI Docker container"
run = "docker compose -f deploy/docker/docker-compose.yml down"

[tasks."docker:down:https"]
description = "Stop AionUI Docker container"
run = "docker compose -f deploy/docker/docker-compose.yml --profile https down"

[tasks."docker:logs"]
description = "Follow AionUI Docker container logs"
run = "docker compose -f deploy/docker/docker-compose.yml logs -f"

[tasks."docker:logs:https"]
description = "Follow AionUI Docker container logs"
run = "docker compose -f deploy/docker/docker-compose.yml --profile https logs -f"

# â”€â”€â”€ Drift Detect Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Integration with Drift Detect for pattern analysis and code health

[tasks."typecheck"]
description = "Run TypeScript type checking (no emit)"
run = "npx tsc --noEmit"

[tasks."lint:python"]
description = "Lint Python scripts with ruff"
run = "ruff check skills/"

[tasks."lint:python:fix"]
description = "Lint and auto-fix Python scripts with ruff"
run = "ruff check --fix skills/ && ruff format skills/"

# â”€â”€â”€ Drift Detect Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Pattern analysis and code health. Drift requires Node 25 (native modules).
# The pre-push hook runs 'drift:check' automatically before each push.

[tasks."drift:status"]
description = "Show Drift Detect pattern health"
run = "drift status"

[tasks."drift:audit"]
description = "Run Drift Detect audit"
run = "drift audit --review"

[tasks."drift:approve"]
description = "Approve high confidence patterns"
run = "drift approve --auto"

[tasks."drift:check"]
description = "Run Drift Detect pattern validation"
run = "drift check"

[tasks."drift:dashboard"]
description = "Open Drift Detect dashboard"
run = "drift dashboard"

[tasks."drift:scan"]
description = "Run full Drift Detect scan"
run = "drift scan"

[tasks."drift:export"]
description = "Export Drift AI context (for AI assistants)"
run = "drift export --format ai-context --compact"

[tasks."drift:memory"]
description = "Show Drift Cortex memory health"
run = "drift memory status"

[tasks."drift:memory:why"]
description = "Get context for a feature area (usage: mise run drift:memory:why <area>)"
run = 'drift memory why "$1"'

[tasks."drift:memory:learn"]
description = "Record a lesson learned (usage: mise run drift:memory:learn 'lesson text')"
run = 'drift memory learn "$1"'

[tasks."drift:memory:search"]
description = "Search Cortex memories (usage: mise run drift:memory:search 'query')"
run = 'drift memory search "$1"'

[tasks."drift:env"]
description = "Audit sensitive env var access"
run = "drift env secrets"

[tasks."drift:boundaries"]
description = "Verify data access boundaries"
run = "drift boundaries check"

[tasks."drift:dna"]
description = "Check style consistency (DNA mutations)"
run = "drift dna mutations"

[tasks."drift:dna:playbook"]
description = "Regenerate STYLING-PLAYBOOK.md (gitignored, local reference)"
run = "drift dna playbook"

[tasks."drift:health"]
description = "Show Drift Detect health summary"
run = """
echo "=== Drift Detect Health ==="
drift health 2>/dev/null || echo "(drift not installed â€” run: npm i -g driftdetect)"
echo ""
echo "=== Pattern Summary ==="
drift export --format summary 2>/dev/null || true
"""

# â”€â”€â”€ Release & Changelog Tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Release workflow and automated changelog generation via git-cliff.
# See: cliff.toml for template and parser configuration.

[tasks.release]
description = "Release a new version (usage: mise run release [patch|minor|major|X.Y.Z])"
run = """
#!/usr/bin/env bash
set -euo pipefail

# Ensure clean working tree
if [ -n "$(git status --porcelain)" ]; then
  echo "âŒ Working tree not clean. Commit or stash changes first."
  exit 1
fi

# Determine version
VERSION_ARG="${1:-}"
if [ -z "$VERSION_ARG" ]; then
  NEXT_VERSION=$(git cliff --bumped-version)
  echo "ğŸ“¦ Next version (auto): $NEXT_VERSION"
else
  case "$VERSION_ARG" in
    patch|minor|major)
      CURRENT=$(node -p "require('./package.json').version")
      IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
      case "$VERSION_ARG" in
        patch) NEXT_VERSION="v$MAJOR.$MINOR.$((PATCH + 1))" ;;
        minor) NEXT_VERSION="v$MAJOR.$((MINOR + 1)).0" ;;
        major) NEXT_VERSION="v$((MAJOR + 1)).0.0" ;;
      esac ;;
    *) NEXT_VERSION="v${VERSION_ARG#v}" ;;
  esac
  echo "ğŸ“¦ Next version (explicit): $NEXT_VERSION"
fi

# Preview
echo ""
echo "=== Unreleased Changes ==="
git cliff --unreleased --strip header
echo ""
read -p "Release $NEXT_VERSION? [y/N] " -n 1 -r
echo ""
[[ ! $REPLY =~ ^[Yy]$ ]] && echo "Aborted." && exit 0

# Update version in package.json
VERSION_NUM=${NEXT_VERSION#v}
node -e "
  const pkg = require('./package.json');
  pkg.version = '$VERSION_NUM';
  require('fs').writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\\n');
"

# Regenerate styling playbook (gitignored, but keeps local copy fresh)
echo "ğŸ“ Regenerating styling playbook..."
drift dna playbook 2>/dev/null || echo "âš ï¸  drift dna playbook skipped (drift not available)"

# Generate changelog
git cliff --tag "$NEXT_VERSION" -o CHANGELOG.md

# Commit, tag
git add package.json CHANGELOG.md
git commit -m "chore(release): $NEXT_VERSION"
git tag -a "$NEXT_VERSION" -m "Release $NEXT_VERSION"
echo "âœ… Tagged $NEXT_VERSION"
echo ""
read -p "Push to origin? [y/N] " -n 1 -r
echo ""
[[ ! $REPLY =~ ^[Yy]$ ]] && echo "Tag created locally. Run: git push && git push --tags" && exit 0
git push && git push --tags
echo "ğŸš€ Released $NEXT_VERSION"
"""

[tasks.changelog]
description = "Generate CHANGELOG.md from git history"
run = "git cliff -o CHANGELOG.md"

[tasks."changelog:latest"]
description = "Show changelog for latest release only"
run = "git cliff --latest --strip header"

[tasks."changelog:unreleased"]
description = "Preview unreleased changes"
run = "git cliff --unreleased"

[tasks."changelog:bump"]
description = "Show what the next version would be"
run = "git cliff --bumped-version"
